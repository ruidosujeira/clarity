#!/usr/bin/env node

const readline = require('readline');
const { spawn } = require('child_process');
const runClarity = require('../src/core/runner');
const { listLogs, formatEntries, readLogFile } = require('../src/core/logsList');
const { getLogsDir } = require('../src/utils/logs');
const pkg = require('../package.json');

function showHelp() {
  const message = `CLΛRITY - minimalist terminal wrapper\n\n` +
    `Usage:\n` +
    `  clarity <command> [args...] [--details] [--full] [--raw] [--profile <name>]\n` +
    `  clarity doctor\n` +
    `  clarity watch <command> [args...] [--interval <sec>] [--count <n>] [--profile <name>]\n\n` +
    `Examples:\n` +
    `  clarity npm install\n` +
    `  clarity git push\n` +
    `  clarity docker build .\n` +
    `  clarity logs --limit 5\n` +
    `  clarity logs --open\n` +
    `  clarity logs --pager\n` +
    `  clarity logs --editor --latest\n` +
    `  clarity doctor\n` +
    `  clarity --profile devops git push\n` +
    `  clarity --help`;
  console.log(message);
}

async function main() {
  const argv = process.argv.slice(2);
  if (argv.length === 0 || argv.includes('--help') || argv.includes('-h')) {
    showHelp();
    process.exit(argv.length === 0 ? 0 : 0);
    return;
  }

  if (argv[0] === 'doctor') {
    printDoctor();
    process.exit(0);
    return;
  }

  if (argv[0] === 'watch') {
    const { cmd, cmdArgs, interval, count, profile } = parseWatchArgs(argv.slice(1));
    if (!cmd) {
      console.error('Usage: clarity watch <command> [args...] [--interval <sec>] [--count <n>] [--profile <name>]');
      process.exit(1);
      return;
    }
    await runWatch(cmd, cmdArgs, { interval, count, profile });
    return;
  }

  if (argv[0] === 'logs' || argv.includes('--logs')) {
    const logsArgs = argv[0] === 'logs'
      ? argv.slice(1)
      : argv.filter((arg) => arg !== '--logs');
    const options = parseLogsOptions(logsArgs);
    const { limit, openMode, autoSelectLatest } = options;
    const entries = listLogs({ limit });
    console.log(formatEntries(entries));

    if (openMode !== 'none') {
      if (!entries.length) {
        console.log('No logs available to open.');
      } else if (openMode === 'inline') {
        await openLogInline(entries, autoSelectLatest);
      } else if (openMode === 'pager') {
        await openLogInPager(entries, options.pagerCommand, autoSelectLatest);
      } else if (openMode === 'editor') {
        await openLogInEditor(entries, options.editorCommand, autoSelectLatest);
      }
    }

    process.exit(0);
    return;
  }

  let command = argv[0];
  const rest = argv.slice(1);

  const options = {
    details: false,
    full: false,
    raw: false,
    profile: 'calm'
  };

  const commandArgs = [];
  let skipNext = false;
  for (let i = 0; i < rest.length; i++) {
    if (skipNext) {
      skipNext = false;
      continue;
    }
    const arg = rest[i];
    if (arg === '--full') {
      options.full = true;
      continue;
    }
    if (arg === '--details') {
      options.details = true;
      continue;
    }
    if (arg === '--raw') {
      options.raw = true;
      continue;
    }
    if (arg === '--profile') {
      const next = rest[i + 1];
      if (next) {
        options.profile = next;
        skipNext = true;
      }
      continue;
    }
    if (arg.startsWith('--profile=')) {
      options.profile = arg.split('=')[1] || options.profile;
      continue;
    }
    commandArgs.push(arg);
  }

  if (!command) {
    console.error('Error: no command provided.');
    showHelp();
    process.exit(1);
    return;
  }

  try {
    const exitCode = await runClarity({ command, args: commandArgs, options });
    process.exitCode = exitCode;
  } catch (err) {
    console.error('Error while running CLΛRITY:', err.message);
    process.exit(1);
  }
}

function printDoctor() {
  const lines = [];
  lines.push('CLΛRITY doctor');
  lines.push('');
  lines.push(`Version: ${pkg.version || 'unknown'}`);
  lines.push(`Node: ${process.version}`);
  lines.push(`Logs directory: ${getLogsDir()}`);
  lines.push('');
  lines.push('Environment:');
  const envs = [
    'CLARITY_PROFILE',
    'CLARITY_LOGS_DIR',
    'CLARITY_PAGER',
    'PAGER',
    'CLARITY_EDITOR',
    'EDITOR',
    'VISUAL',
    'CLARITY_DEBUG'
  ];
  envs.forEach((name) => {
    const val = process.env[name];
    lines.push(`  ${name}=${val !== undefined ? val : '(unset)'}`);
  });
  console.log(lines.join('\n'));
}

function parseWatchArgs(args) {
  let interval = 5;
  let count = Infinity;
  let profile = 'calm';
  const cmdArgs = [];
  let cmd = null;
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '--interval') {
      const v = Number(args[i + 1]);
      if (!Number.isNaN(v)) interval = v;
      i++;
      continue;
    }
    if (a.startsWith('--interval=')) {
      const v = Number(a.split('=')[1]);
      if (!Number.isNaN(v)) interval = v;
      continue;
    }
    if (a === '--count') {
      const v = Number(args[i + 1]);
      if (!Number.isNaN(v)) count = v;
      i++;
      continue;
    }
    if (a.startsWith('--count=')) {
      const v = Number(a.split('=')[1]);
      if (!Number.isNaN(v)) count = v;
      continue;
    }
    if (a === '--profile') {
      const v = args[i + 1];
      if (v) profile = v;
      i++;
      continue;
    }
    if (a.startsWith('--profile=')) {
      profile = a.split('=')[1] || profile;
      continue;
    }
    if (!cmd) {
      cmd = a;
    } else {
      cmdArgs.push(a);
    }
  }
  return { cmd, cmdArgs, interval, count, profile };
}

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

async function runWatch(command, args, { interval = 5, count = Infinity, profile = 'calm' } = {}) {
  let stopped = false;
  process.on('SIGINT', () => {
    stopped = true;
    process.stderr.write('\n[clarity] watch stopped by user (Ctrl+C).\n');
  });

  let i = 0;
  let lastCode = 0;
  while (!stopped && i < count) {
    const iter = i + 1;
    const ts = new Date().toLocaleTimeString();
    console.log(`\n=== clarity watch: iteration ${iter} @ ${ts} ===`);
    // Reuse runClarity for each iteration
    lastCode = await runClarity({ command, args, options: { profile } });
    i++;
    if (!stopped && i < count) {
      await sleep(Math.max(0, interval) * 1000);
    }
  }
  process.exit(lastCode);
}

function parseLogsOptions(args) {
  let limit = 10;
  let openMode = 'none';
  const defaultPager = process.env.CLARITY_PAGER || process.env.PAGER || process.env.EDITOR || 'less';
  const defaultEditor = process.env.CLARITY_EDITOR || process.env.VISUAL || process.env.EDITOR || 'nano';
  let pagerCommand = defaultPager;
  let editorCommand = defaultEditor;
  let autoSelectLatest = false;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--limit') {
      const value = Number(args[i + 1]);
      if (!Number.isNaN(value) && value > 0) {
        limit = value;
      }
      i += 1;
      continue;
    }
    if (arg.startsWith('--limit=')) {
      const value = Number(arg.split('=')[1]);
      if (!Number.isNaN(value) && value > 0) {
        limit = value;
      }
      continue;
    }
    if (arg === '--open' || arg === '--view' || arg === 'open' || arg === '--open-inline') {
      openMode = 'inline';
      continue;
    }
    if (
      arg === '--open=pager' ||
      arg === '--pager' ||
      arg === 'pager' ||
      arg === '--open-pager'
    ) {
      openMode = 'pager';
      continue;
    }
    if (arg.startsWith('--pager=')) {
      openMode = 'pager';
      const value = arg.split('=')[1];
      if (value) {
        pagerCommand = value;
      }
      continue;
    }
    if (arg === '--open-with') {
      openMode = 'pager';
      const value = args[i + 1];
      if (value) {
        pagerCommand = value;
      }
      i += 1;
      continue;
    }
    if (
      arg === '--editor' ||
      arg === '--open=editor' ||
      arg === '--open-editor' ||
      arg === '--edit'
    ) {
      openMode = 'editor';
      continue;
    }
    if (arg.startsWith('--editor=')) {
      openMode = 'editor';
      const value = arg.split('=')[1];
      if (value) {
        editorCommand = value;
      }
      continue;
    }
    if (arg === '--open-with-editor') {
      openMode = 'editor';
      const value = args[i + 1];
      if (value) {
        editorCommand = value;
      }
      i += 1;
      continue;
    }
    if (arg === '--latest' || arg === '--open-latest' || arg === '--auto') {
      autoSelectLatest = true;
      continue;
    }
  }

  if (!autoSelectLatest && openMode !== 'none' && limit === 1) {
    autoSelectLatest = true;
  }

  return { limit, openMode, pagerCommand, editorCommand, autoSelectLatest };
}

function ask(question) {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

async function promptEntrySelection(entries) {
  const answer = await ask('\nSelect the log number to open: ');
  const index = Number(answer) - 1;
  if (Number.isNaN(index) || index < 0 || index >= entries.length) {
    console.log('Invalid selection. Nothing opened.');
    return null;
  }

  return entries[index];
}

async function openLogInline(entries, autoSelectLatest = false) {
  const entry = await selectEntry(entries, autoSelectLatest);
  if (!entry) {
    return;
  }
  const content = readLogFile(entry.path);
  if (!content) {
    console.log('Could not read the selected log file.');
    return;
  }

  console.log(`\n=== ${entry.fileName} ===`);
  process.stdout.write(content);
  console.log('\n=== end of log ===');
}

async function openLogInPager(entries, pagerCommand, autoSelectLatest = false) {
  const entry = await selectEntry(entries, autoSelectLatest);
  if (!entry) {
    return;
  }

  await openLogWithCommand(entry, pagerCommand, 'pager');
}

async function openLogInEditor(entries, editorCommand, autoSelectLatest = false) {
  const entry = await selectEntry(entries, autoSelectLatest);
  if (!entry) {
    return;
  }

  await openLogWithCommand(entry, editorCommand, 'editor');
}

async function selectEntry(entries, autoSelectLatest) {
  if (autoSelectLatest) {
    return entries[0];
  }
  return promptEntrySelection(entries);
}

async function openLogWithCommand(entry, commandString, label) {
  const cmd = commandString || (label === 'editor' ? 'nano' : 'less');
  const parts = cmd.split(/\s+/).filter(Boolean);
  if (!parts.length) {
    console.log(`No valid ${label} configured.`);
    return;
  }

  const bin = parts[0];
  const extraArgs = parts.slice(1);
  console.log(`Opening ${entry.fileName} with ${bin}...`);

  await new Promise((resolve) => {
    const child = spawn(bin, [...extraArgs, entry.path], {
      stdio: 'inherit'
    });

    child.on('error', () => {
      console.log(`Failed to open the specified ${label}.`);
      resolve();
    });

    child.on('close', () => resolve());
  });
}

main();
